# My Programming Journey: 100 Steps to Mastery

This repository tracks my progress through a list of 100 programming tasks, from "Hello, World!" to building an operating system kernel. Each checked item represents a completed challenge on my journey to becoming a proficient developer.

---

## The Checklist

- [x] Display "Hello, World!"
- [x] Get user input and print it back.
- [ ] Create a button that shows an alert when clicked.
- [ ] Make a counter that increments with each button click.
- [ ] Build a simple calculator for addition.
- [ ] Fetch and display a random joke from a public API.
- [ ] Create a to-do list where you can add items.
- [ ] Add a feature to remove items from the to-do list.
- [ ] Save the to-do list items to the browser's local storage.
- [ ] Add user accounts (sign up/log in).
- [ ] Save user-specific to-do lists to a remote database.
- [ ] Allow users to edit existing items in their list.
- [ ] Add a "completed" status that users can toggle.
- [ ] Implement password reset via email.
- [ ] Allow users to upload a profile picture.
- [ ] Implement a search bar to filter the to-do list.
- [ ] Allow users to sort the list (e.g., by date, alphabetically).
- [ ] Add due dates to to-do items.
- [ ] Send users an email notification for an upcoming due date.
- [ ] Allow users to share their to-do lists with others (read-only).
- [ ] Implement user roles (owner, editor, viewer) for shared lists.
- [ ] Add a real-time chat feature for users viewing a shared list.
- [ ] Display typing indicators ("...is typing") in the chat.
- [ ] Store chat history in the database.
- [ ] Paginate the to-do list to handle thousands of items.
- [ ] Write a unit test for the calculator logic.
- [ ] Write an integration test for the login flow.
- [ ] Refactor the code into separate modules or components.
- [ ] Set up a linter to enforce a consistent code style.
- [ ] Put the project under version control with Git.
- [ ] Create a "dark mode" theme for the application.
- [ ] Make the application responsive for mobile devices.
- [ ] Implement client-side routing for a Single-Page Application (SPA).
- [ ] Manage application state with a state management library (e.g., Redux).
- [ ] Authenticate users using a third-party provider (e.g., Google OAuth).
- [ ] Build a RESTful API for your backend.
- [ ] Secure the API using JWTs (JSON Web Tokens).
- [ ] Add API documentation.
- [ ] Implement API rate limiting.
- [ ] Containerize the application using Docker.
- [ ] Set up a CI/CD pipeline to automate testing and deployment.
- [ ] Deploy the application to a cloud provider (e.g., AWS, GCP).
- [ ] Add logging to monitor application events.
- [ ] Create a dashboard to view application metrics.
- [ ] Implement a caching layer (e.g., with Redis) to speed up API responses.
- [ ] Use a message queue for long-running background tasks (e.g., sending emails).
- [ ] Make the app a Progressive Web App (PWA) so it can be "installed."
- [ ] Implement offline support using service workers.
- [ ] Add internationalization (i18n) to support multiple languages.
- [ ] Implement full-text search on to-do items (e.g., with Elasticsearch).
- [ ] Add keyboard shortcuts to the application.
- [ ] Ensure the application is accessible (a11y compliant).
- [ ] Optimize frontend performance (code splitting, lazy loading).
- [ ] Optimize database performance with indexes and query analysis.
- [ ] Implement optimistic UI updates for a faster perceived performance.
- [ ] Create an admin panel to manage users and data.
- [ ] Generate reports and data visualizations from user data.
- [ ] Implement A/B testing for a new feature.
- [ ] Build a recommendation engine (e.g., suggest "smart" to-do items).
- [ ] Break the monolithic backend into two separate microservices.
- [ ] Implement inter-service communication (e.g., via REST or gRPC).
- [ ] Set up an API Gateway for the microservices.
- [ ] Implement a service discovery mechanism.
- [ ] Add distributed tracing to monitor requests across services.
- [ ] Set up a load balancer to distribute traffic.
- [ ] Scale the database with read replicas.
- [ ] Implement a WebSocket server for the real-time chat instead of using a third party.
- [ ] Implement end-to-end encryption for the chat messages.
- [ ] Build a browser extension for your application.
- [ ] Create a command-line interface (CLI) to manage your application.
- [ ] Build a simple plugin or addon system.
- [ ] Implement feature flags to toggle features without deploying new code.
- [ ] Write a scraper to import data from another source.
- [ ] Build a mobile app version using a cross-platform framework (e.g., React Native).
- [ ] Write native iOS or Android components for the mobile app.
- [ ] Shard the database to distribute data across multiple machines.
- [ ] Implement a real-time data processing pipeline (e.g., with Kafka).
- [ ] Design and build a multi-tenant architecture.
- [ ] Implement a Circuit Breaker pattern for resilience.
- [ ] Set up a Kubernetes cluster to orchestrate your containers.
- [ ] Implement a custom authentication server using OAuth2.
- [ ] Use WebRTC to add video chat capabilities.
- [ ] Train a custom machine learning model for your recommendation engine.
- [ ] Write a simple WebAssembly module for a performance-critical task.
- [ ] Build a collaborative text editor (like Google Docs).
- [ ] Implement Conflict-Free Replicated Data Types (CRDTs) for collaboration.
- [ ] Create a simple SQL query engine.
- [ ] Build a custom memory allocator.
- [ ] Write a basic thread scheduler.
- [ ] Build a simple key-value store database from scratch.
- [ ] Implement a Raft consensus algorithm for your distributed store.
- [ ] Create a simple virtual machine (VM).
- [ ] Write an interpreter for a simple Lisp-like language.
- [ ] Write a transpiler from one language to another (e.g., custom language to JavaScript).
- [ ] Build a simple TCP/IP stack.
- [ ] Create a basic 2D physics engine.
- [ ] Write a simple ray tracer to render 3D scenes.
- [ ] Build a compiler for a simple, custom programming language.
- [ ] Write a simple file system.
- [ ] Build a basic operating system kernel.

---

## How to Use

1.  As a task is completed, check it off by changing `[ ]` to `[x]`.
2.  Commit the changes to log your progress.
3.  (Optional) Create a separate folder for each major project to store the source code.

## Tools & Environment

* **Language(s):** C, ARM64 Assembly
* **OS:** macOS (Apple Silicon)
* **Editor:** Neovim
* **Compiler/Tools:** Clang, Xcode Command Line Tools
